{
  "addressing_modes": "x86_64_complete",
  "description": "Complete x86-64 addressing modes per Intel SDM and AT&T syntax",
  "reference": "Intel SDM Volume 2A, OSDev Wiki x86-64 Instruction Encoding",
  "modes": [
    {
      "name": "register_direct",
      "description": "Direct register addressing",
      "syntax_patterns": [
        "%rax", "%rbx", "%rcx", "%rdx", "%rsi", "%rdi", "%rsp", "%rbp",
        "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15",
        "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi", "%esp", "%ebp",
        "%r8d", "%r9d", "%r10d", "%r11d", "%r12d", "%r13d", "%r14d", "%r15d",
        "%ax", "%bx", "%cx", "%dx", "%si", "%di", "%sp", "%bp",
        "%r8w", "%r9w", "%r10w", "%r11w", "%r12w", "%r13w", "%r14w", "%r15w",
        "%al", "%bl", "%cl", "%dl", "%sil", "%dil", "%spl", "%bpl",
        "%r8b", "%r9b", "%r10b", "%r11b", "%r12b", "%r13b", "%r14b", "%r15b",
        "%ah", "%bh", "%ch", "%dh"
      ],
      "test_cases": [
        {
          "syntax": "movq %rax, %rbx", 
          "description": "64-bit register to register",
          "expected_encoding": "48 89 C3",
          "encoding_length": 3,
          "intel_reference": "REX.W + 89 /r (MOV r/m64, r64)",
          "note": "REX.W=1 (48), ModR/M=C3 (mod=11 reg=000 r/m=011)"
        },
        {
          "syntax": "movl %eax, %ebx", 
          "description": "32-bit register to register",
          "expected_encoding": "89 C3",
          "encoding_length": 2,
          "intel_reference": "89 /r (MOV r/m32, r32)",
          "note": "ModR/M=C3 (mod=11 reg=000 r/m=011)"
        },
        {
          "syntax": "movw %ax, %bx", 
          "description": "16-bit register to register",
          "expected_encoding": "66 89 C3",
          "encoding_length": 3,
          "intel_reference": "66 89 /r (MOV r/m16, r16)",
          "note": "Operand-size prefix 66, ModR/M=C3"
        },
        {
          "syntax": "movb %al, %bl", 
          "description": "8-bit register to register",
          "expected_encoding": "88 C3",
          "encoding_length": 2,
          "intel_reference": "88 /r (MOV r/m8, r8)",
          "note": "ModR/M=C3 (mod=11 reg=000 r/m=011)"
        },
        {
          "syntax": "movq %r8, %r15", 
          "description": "Extended 64-bit registers",
          "expected_encoding": "4D 89 C7",
          "encoding_length": 3,
          "intel_reference": "REX.WRB + 89 /r (MOV r/m64, r64)",
          "note": "REX.W=1,R=1,B=1 (4D), ModR/M=C7 (r8->r15)"
        },
        {
          "syntax": "movl %r8d, %r15d", 
          "description": "Extended 32-bit registers",
          "expected_encoding": "45 89 C7",
          "encoding_length": 3,
          "intel_reference": "REX.RB + 89 /r (MOV r/m32, r32)",
          "note": "REX.R=1,B=1 (45), ModR/M=C7"
        },
        {
          "syntax": "movw %r8w, %r15w", 
          "description": "Extended 16-bit registers",
          "expected_encoding": "66 45 89 C7",
          "encoding_length": 4,
          "intel_reference": "66 REX.RB + 89 /r (MOV r/m16, r16)",
          "note": "Operand-size prefix + REX.R=1,B=1"
        },
        {
          "syntax": "movb %r8b, %r15b", 
          "description": "Extended 8-bit registers",
          "expected_encoding": "45 88 C7",
          "encoding_length": 3,
          "intel_reference": "REX.RB + 88 /r (MOV r/m8, r8)",
          "note": "REX.R=1,B=1 (45), ModR/M=C7"
        },
        {
          "syntax": "movb %sil, %dil", 
          "description": "Low 8-bit of index registers",
          "expected_encoding": "40 88 F7",
          "encoding_length": 3,
          "intel_reference": "REX + 88 /r (MOV r/m8, r8)",
          "note": "REX prefix needed for SIL/DIL access, ModR/M=F7"
        }
      ]
    },
    {
      "name": "immediate",
      "description": "Immediate constant addressing",
      "syntax_patterns": [
        "$imm8", "$imm16", "$imm32", "$imm64"
      ],
      "test_cases": [
        {
          "syntax": "movq $0x1234567890ABCDEF, %rax", 
          "description": "64-bit immediate",
          "expected_encoding": "48 B8 EF CD AB 90 78 56 34 12",
          "encoding_length": 10,
          "intel_reference": "REX.W + B8+ rd io (MOV r64, imm64)",
          "note": "REX.W + opcode B8 + 8-byte immediate in little-endian"
        },
        {
          "syntax": "movl $0x12345678, %eax", 
          "description": "32-bit immediate",
          "expected_encoding": "B8 78 56 34 12",
          "encoding_length": 5,
          "intel_reference": "B8+ rd id (MOV r32, imm32)",
          "note": "Opcode B8 + 4-byte immediate in little-endian"
        },
        {
          "syntax": "movw $0x1234, %ax", 
          "description": "16-bit immediate",
          "expected_encoding": "66 B8 34 12",
          "encoding_length": 4,
          "intel_reference": "66 B8+ rw iw (MOV r16, imm16)",
          "note": "Operand-size prefix + B8 + 2-byte immediate"
        },
        {
          "syntax": "movb $0x12, %al", 
          "description": "8-bit immediate",
          "expected_encoding": "B0 12",
          "encoding_length": 2,
          "intel_reference": "B0+ rb ib (MOV r8, imm8)",
          "note": "Opcode B0 for AL + 1-byte immediate"
        },
        {
          "syntax": "addq $1, %rax", 
          "description": "Small immediate addition",
          "expected_encoding": "48 83 C0 01",
          "encoding_length": 4,
          "intel_reference": "REX.W + 83 /0 ib (ADD r/m64, imm8)",
          "note": "REX.W + 83 /0 + sign-extended 8-bit immediate"
        },
        {
          "syntax": "addq $-128, %rax", 
          "description": "Negative immediate",
          "expected_encoding": "48 83 C0 80",
          "encoding_length": 4,
          "intel_reference": "REX.W + 83 /0 ib (ADD r/m64, imm8)",
          "note": "REX.W + 83 /0 + 0x80 (-128 as signed byte)"
        },
        {
          "syntax": "cmpq $0, %rax", 
          "description": "Compare with zero immediate",
          "expected_encoding": "48 83 F8 00",
          "encoding_length": 4,
          "intel_reference": "REX.W + 83 /7 ib (CMP r/m64, imm8)",
          "note": "REX.W + 83 /7 + 0x00 immediate"
        }
      ]
    },
    {
      "name": "memory_direct",
      "description": "Direct memory addressing",
      "syntax_patterns": [
        "(%reg)", "disp(%reg)", "label", "label(%rip)"
      ],
      "test_cases": [
        {
          "syntax": "movq (%rax), %rbx", 
          "description": "Register indirect",
          "expected_encoding": "48 8B 18",
          "encoding_length": 3,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=18 (mod=00 reg=011 r/m=000)"
        },
        {
          "syntax": "movq (%r8), %rbx", 
          "description": "Extended register indirect",
          "expected_encoding": "49 8B 18",
          "encoding_length": 3,
          "intel_reference": "REX.WB + 8B /r (MOV r64, r/m64)",
          "note": "REX.W=1,B=1 (49) + ModR/M=18"
        },
        {
          "syntax": "movq 8(%rax), %rbx", 
          "description": "Register indirect with 8-bit displacement",
          "expected_encoding": "48 8B 58 08",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=58 (mod=01) + disp8=08"
        },
        {
          "syntax": "movq 256(%rax), %rbx", 
          "description": "Register indirect with 32-bit displacement",
          "expected_encoding": "48 8B 98 00 01 00 00",
          "encoding_length": 7,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=98 (mod=10) + disp32=0x00000100"
        },
        {
          "syntax": "movq -8(%rax), %rbx", 
          "description": "Register indirect with negative displacement",
          "expected_encoding": "48 8B 58 F8",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=58 + disp8=F8 (-8)"
        },
        {
          "syntax": "movq (%rsp), %rax", 
          "description": "Stack pointer indirect",
          "expected_encoding": "48 8B 04 24",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=04 + SIB=24 (RSP needs SIB)"
        },
        {
          "syntax": "movq (%rbp), %rax", 
          "description": "Base pointer indirect",
          "expected_encoding": "48 8B 45 00",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=45 + disp8=00 (RBP needs displacement)"
        },
        {
          "syntax": "movq 16(%rbp), %rax", 
          "description": "Stack frame access",
          "expected_encoding": "48 8B 45 10",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=45 + disp8=10"
        }
      ]
    },
    {
      "name": "rip_relative",
      "description": "RIP-relative addressing (x86-64 specific)",
      "syntax_patterns": [
        "label(%rip)", "disp(%rip)"
      ],
      "test_cases": [
        {
          "syntax": "movq variable(%rip), %rax", 
          "description": "RIP-relative variable access",
          "expected_encoding": "48 8B 05 00 00 00 00",
          "encoding_length": 7,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=05 + disp32 (RIP-relative)"
        },
        {
          "syntax": "leaq string(%rip), %rdi", 
          "description": "RIP-relative address loading",
          "expected_encoding": "48 8D 3D 00 00 00 00",
          "encoding_length": 7,
          "intel_reference": "REX.W + 8D /r (LEA r64, m)",
          "note": "REX.W + 8D + ModR/M=3D + disp32 (RIP-relative LEA)"
        },
        {
          "syntax": "callq function(%rip)", 
          "description": "RIP-relative function call",
          "expected_encoding": "E8 00 00 00 00",
          "encoding_length": 5,
          "intel_reference": "E8 cd (CALL rel32)",
          "note": "Direct call with 32-bit relative displacement"
        },
        {
          "syntax": "cmpq $0, flag(%rip)", 
          "description": "RIP-relative comparison",
          "expected_encoding": "48 83 3D 00 00 00 00 00",
          "encoding_length": 8,
          "intel_reference": "REX.W + 83 /7 ib (CMP r/m64, imm8)",
          "note": "REX.W + 83 /7 + ModR/M=3D + disp32 + imm8=00"
        },
        {
          "syntax": "addq data(%rip), %rax", 
          "description": "RIP-relative arithmetic",
          "expected_encoding": "48 03 05 00 00 00 00",
          "encoding_length": 7,
          "intel_reference": "REX.W + 03 /r (ADD r64, r/m64)",
          "note": "REX.W + 03 + ModR/M=05 + disp32 (RIP-relative)"
        },
        {
          "syntax": "movq %rax, result(%rip)", 
          "description": "RIP-relative store operation",
          "expected_encoding": "48 89 05 00 00 00 00",
          "encoding_length": 7,
          "intel_reference": "REX.W + 89 /r (MOV r/m64, r64)",
          "note": "REX.W + 89 + ModR/M=05 + disp32 (RIP-relative store)"
        },
        {
          "syntax": "pushq value(%rip)", 
          "description": "RIP-relative push",
          "expected_encoding": "FF 35 00 00 00 00",
          "encoding_length": 6,
          "intel_reference": "FF /6 (PUSH r/m64)",
          "note": "FF /6 + ModR/M=35 + disp32 (RIP-relative push)"
        }
      ]
    },
    {
      "name": "sib_scale_index_base",
      "description": "SIB (Scale-Index-Base) addressing",
      "syntax_patterns": [
        "(%base,%index,scale)", "disp(%base,%index,scale)",
        "(,%index,scale)", "disp(,%index,scale)"
      ],
      "test_cases": [
        {
          "syntax": "movq (%rax,%rbx,1), %rcx", 
          "description": "SIB with scale 1",
          "expected_encoding": "48 8B 0C 18",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=0C + SIB=18 (scale=00,index=011,base=000)"
        },
        {
          "syntax": "movq (%rax,%rbx,2), %rcx", 
          "description": "SIB with scale 2",
          "expected_encoding": "48 8B 0C 58",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=0C + SIB=58 (scale=01,index=011,base=000)"
        },
        {
          "syntax": "movq (%rax,%rbx,4), %rcx", 
          "description": "SIB with scale 4",
          "expected_encoding": "48 8B 0C 98",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=0C + SIB=98 (scale=10,index=011,base=000)"
        },
        {
          "syntax": "movq (%rax,%rbx,8), %rcx", 
          "description": "SIB with scale 8",
          "expected_encoding": "48 8B 0C D8",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=0C + SIB=D8 (scale=11,index=011,base=000)"
        },
        {
          "syntax": "movq 16(%rax,%rbx,4), %rcx", 
          "description": "SIB with displacement",
          "expected_encoding": "48 8B 4C 98 10",
          "encoding_length": 5,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=4C + SIB=98 + disp8=10"
        },
        {
          "syntax": "movq -8(%rax,%rbx,2), %rcx", 
          "description": "SIB with negative displacement",
          "expected_encoding": "48 8B 4C 58 F8",
          "encoding_length": 5,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=4C + SIB=58 + disp8=F8 (-8)"
        },
        {
          "syntax": "movq (,%rbx,4), %rcx", 
          "description": "SIB without base register",
          "expected_encoding": "48 8B 0C 9D 00 00 00 00",
          "encoding_length": 8,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=0C + SIB=9D + disp32=00000000"
        },
        {
          "syntax": "movq 100(,%rbx,8), %rcx", 
          "description": "SIB without base, with displacement",
          "expected_encoding": "48 8B 0C DD 64 00 00 00",
          "encoding_length": 8,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=0C + SIB=DD + disp32=00000064"
        },
        {
          "syntax": "movq (%rax,%r8,4), %rcx", 
          "description": "SIB with extended index register",
          "expected_encoding": "4A 8B 0C 80",
          "encoding_length": 4,
          "intel_reference": "REX.WX + 8B /r (MOV r64, r/m64)",
          "note": "REX.W=1,X=1 (4A) + 8B + ModR/M=0C + SIB=80"
        },
        {
          "syntax": "movq (%r9,%rbx,2), %rcx", 
          "description": "SIB with extended base register",
          "expected_encoding": "49 8B 0C 59",
          "encoding_length": 4,
          "intel_reference": "REX.WB + 8B /r (MOV r64, r/m64)",
          "note": "REX.W=1,B=1 (49) + 8B + ModR/M=0C + SIB=59"
        },
        {
          "syntax": "movq (%r9,%r8,4), %rcx", 
          "description": "SIB with both extended registers",
          "expected_encoding": "4B 8B 0C 81",
          "encoding_length": 4,
          "intel_reference": "REX.WXB + 8B /r (MOV r64, r/m64)",
          "note": "REX.W=1,X=1,B=1 (4B) + 8B + ModR/M=0C + SIB=81"
        }
      ]
    },
    {
      "name": "complex_memory",
      "description": "Complex memory addressing combinations",
      "syntax_patterns": [
        "segment:offset", "disp32", "abs64"
      ],
      "test_cases": [
        {
          "syntax": "movq %rax, (%rbx,%rcx,2)", 
          "description": "Register to SIB memory",
          "expected_encoding": "48 89 04 4B",
          "encoding_length": 4,
          "intel_reference": "REX.W + 89 /r (MOV r/m64, r64)",
          "note": "REX.W + 89 + ModR/M=04 + SIB=4B (scale=01,index=001,base=011)"
        },
        {
          "syntax": "addq 8(%rsp,%rax,4), %rbx", 
          "description": "SIB stack access with arithmetic",
          "expected_encoding": "48 03 5C 84 08",
          "encoding_length": 5,
          "intel_reference": "REX.W + 03 /r (ADD r64, r/m64)",
          "note": "REX.W + 03 + ModR/M=5C + SIB=84 + disp8=08"
        },
        {
          "syntax": "leaq 64(%rdi,%rsi,8), %rax", 
          "description": "Complex LEA with SIB",
          "expected_encoding": "48 8D 44 F7 40",
          "encoding_length": 5,
          "intel_reference": "REX.W + 8D /r (LEA r64, m)",
          "note": "REX.W + 8D + ModR/M=44 + SIB=F7 + disp8=40"
        },
        {
          "syntax": "movq (%rax,%rbx,1), %rcx", 
          "description": "Array element access",
          "expected_encoding": "48 8B 0C 18",
          "encoding_length": 4,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=0C + SIB=18"
        },
        {
          "syntax": "movq 4(%rax,%rbx,4), %rcx", 
          "description": "Array of 4-byte elements",
          "expected_encoding": "48 8B 4C 98 04",
          "encoding_length": 5,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=4C + SIB=98 + disp8=04"
        },
        {
          "syntax": "movq 8(%rax,%rbx,8), %rcx", 
          "description": "Array of 8-byte elements",
          "expected_encoding": "48 8B 4C D8 08",
          "encoding_length": 5,
          "intel_reference": "REX.W + 8B /r (MOV r64, r/m64)",
          "note": "REX.W + 8B + ModR/M=4C + SIB=D8 + disp8=08"
        }
      ]
    },
    {
      "name": "segment_override",
      "description": "Segment register overrides (mostly legacy in 64-bit)",
      "syntax_patterns": [
        "%fs:offset", "%gs:offset"
      ],
      "test_cases": [
        {
          "syntax": "movq %fs:0, %rax", 
          "description": "FS segment override",
          "expected_encoding": "64 48 8B 04 25 00 00 00 00",
          "encoding_length": 9,
          "intel_reference": "64 REX.W + 8B /r (MOV r64, r/m64)",
          "note": "FS prefix 64 + REX.W + 8B + ModR/M=04 + SIB=25 + disp32=00000000"
        },
        {
          "syntax": "movq %gs:0, %rax", 
          "description": "GS segment override",
          "expected_encoding": "65 48 8B 04 25 00 00 00 00",
          "encoding_length": 9,
          "intel_reference": "65 REX.W + 8B /r (MOV r64, r/m64)",
          "note": "GS prefix 65 + REX.W + 8B + ModR/M=04 + SIB=25 + disp32=00000000"
        },
        {
          "syntax": "movq %fs:8(%rax), %rbx", 
          "description": "FS override with register indirect",
          "expected_encoding": "64 48 8B 58 08",
          "encoding_length": 5,
          "intel_reference": "64 REX.W + 8B /r (MOV r64, r/m64)",
          "note": "FS prefix 64 + REX.W + 8B + ModR/M=58 + disp8=08"
        },
        {
          "syntax": "movq %gs:(%rax,%rbx,1), %rcx", 
          "description": "GS override with SIB",
          "expected_encoding": "65 48 8B 0C 18",
          "encoding_length": 5,
          "intel_reference": "65 REX.W + 8B /r (MOV r64, r/m64)",
          "note": "GS prefix 65 + REX.W + 8B + ModR/M=0C + SIB=18"
        }
      ]
    },
    {
      "name": "address_size_variations",
      "description": "Address size prefix variations",
      "syntax_patterns": [
        "32-bit addressing in 64-bit mode"
      ],
      "test_cases": [
        {
          "syntax": "addr32 movq (%eax), %rbx", 
          "description": "32-bit address size override",
          "expected_encoding": "67 48 8B 18",
          "encoding_length": 4,
          "intel_reference": "67 REX.W + 8B /r (MOV r64, r/m64)",
          "note": "Address-size prefix 67 + REX.W + 8B + ModR/M=18"
        },
        {
          "syntax": "addr32 movq 4(%eax,%ebx,2), %rcx", 
          "description": "32-bit SIB addressing",
          "expected_encoding": "67 48 8B 4C 58 04",
          "encoding_length": 6,
          "intel_reference": "67 REX.W + 8B /r (MOV r64, r/m64)",
          "note": "Address-size prefix 67 + REX.W + 8B + ModR/M=4C + SIB=58 + disp8=04"
        }
      ]
    }
  ]
}
