{
  "instruction_set": "x86_64_basic",
  "description": "Basic x86-64 instructions - data movement, arithmetic, logical",
  "reference": "Intel SDM Volume 2A/2B",
  "instructions": [
    {
      "mnemonic": "MOV",
      "description": "Move data between registers/memory",
      "operand_types": ["reg", "reg_mem", "imm"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "movq %rax, %rbx", 
          "description": "64-bit register to register",
          "expected_encoding": "48 89 C3",
          "encoding_length": 3,
          "intel_reference": "REX.W + 89 /r (MOV r64, r/m64)"
        },
        {
          "syntax": "movl %eax, %ebx", 
          "description": "32-bit register to register",
          "expected_encoding": "89 C3",
          "encoding_length": 2,
          "intel_reference": "89 /r (MOV r32, r/m32)"
        }, 
        {
          "syntax": "movw %ax, %bx", 
          "description": "16-bit register to register",
          "expected_encoding": "66 89 C3",
          "encoding_length": 3,
          "intel_reference": "66 89 /r (MOV r16, r/m16)"
        },
        {
          "syntax": "movb %al, %bl", 
          "description": "8-bit register to register",
          "expected_encoding": "88 C3",
          "encoding_length": 2,
          "intel_reference": "88 /r (MOV r8, r/m8)"
        },
        {
          "syntax": "movq $0x1234, %rax", 
          "description": "Immediate to 64-bit register",
          "expected_encoding": "48 B8 34 12 00 00 00 00 00 00",
          "encoding_length": 10,
          "intel_reference": "REX.W + B8+rd io (MOV imm64, r64)"
        },
        {
          "syntax": "movq %rax, (%rbx)", 
          "description": "Register to memory",
          "expected_encoding": "48 89 03",
          "encoding_length": 3,
          "intel_reference": "REX.W + 89 /r (MOV r64, r/m64)"
        },
        {
          "syntax": "movq (%rax), %rbx", 
          "description": "Memory to register",
          "expected_encoding": "48 8B 18",
          "encoding_length": 3,
          "intel_reference": "REX.W + 8B /r (MOV r/m64, r64)"
        }
      ]
    },
    {
      "mnemonic": "ADD",
      "description": "Add integers",
      "operand_types": ["reg", "reg_mem", "imm"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "addq %rax, %rbx", 
          "description": "64-bit register addition",
          "expected_encoding": "48 01 C3",
          "encoding_length": 3,
          "intel_reference": "REX.W + 01 /r (ADD r64, r/m64)"
        },
        {
          "syntax": "addl %eax, %ebx", 
          "description": "32-bit register addition",
          "expected_encoding": "01 C3",
          "encoding_length": 2,
          "intel_reference": "01 /r (ADD r32, r/m32)"
        },
        {
          "syntax": "addw %ax, %bx", 
          "description": "16-bit register addition",
          "expected_encoding": "66 01 C3",
          "encoding_length": 3,
          "intel_reference": "66 01 /r (ADD r16, r/m16)"
        },
        {
          "syntax": "addb %al, %bl", 
          "description": "8-bit register addition",
          "expected_encoding": "00 C3",
          "encoding_length": 2,
          "intel_reference": "00 /r (ADD r8, r/m8)"
        },
        {
          "syntax": "addq $10, %rax", 
          "description": "Immediate addition",
          "expected_encoding": "48 83 C0 0A",
          "encoding_length": 4,
          "intel_reference": "REX.W + 83 /0 ib (ADD r/m64, imm8)"
        },
        {
          "syntax": "addq (%rax), %rbx", 
          "description": "Memory to register addition",
          "expected_encoding": "48 03 18",
          "encoding_length": 3,
          "intel_reference": "REX.W + 03 /r (ADD r/m64, r64)"
        }
      ]
    },
    {
      "mnemonic": "SUB", 
      "description": "Subtract integers",
      "operand_types": ["reg", "reg_mem", "imm"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "subq %rax, %rbx", 
          "description": "64-bit register subtraction",
          "expected_encoding": "48 29 C3",
          "encoding_length": 3,
          "intel_reference": "REX.W + 29 /r (SUB r64, r/m64)"
        },
        {
          "syntax": "subl %eax, %ebx", 
          "description": "32-bit register subtraction",
          "expected_encoding": "29 C3",
          "encoding_length": 2,
          "intel_reference": "29 /r (SUB r32, r/m32)"
        },
        {
          "syntax": "subq $5, %rax", 
          "description": "Immediate subtraction",
          "expected_encoding": "48 83 E8 05",
          "encoding_length": 4,
          "intel_reference": "REX.W + 83 /5 ib (SUB r/m64, imm8)"
        }
      ]
    },
    {
      "mnemonic": "MUL",
      "description": "Unsigned multiply",
      "operand_types": ["reg", "reg_mem"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "mulq %rbx", 
          "description": "64-bit unsigned multiply",
          "expected_encoding": "48 F7 E3",
          "encoding_length": 3,
          "intel_reference": "REX.W + F7 /4 (MUL r/m64)"
        },
        {
          "syntax": "mull %ebx", 
          "description": "32-bit unsigned multiply",
          "expected_encoding": "F7 E3",
          "encoding_length": 2,
          "intel_reference": "F7 /4 (MUL r/m32)"
        }
      ]
    },
    {
      "mnemonic": "IMUL",
      "description": "Signed multiply",
      "operand_types": ["reg", "reg_mem", "imm"],
      "sizes": ["16", "32", "64"],
      "test_cases": [
        {
          "syntax": "imulq %rbx", 
          "description": "64-bit signed multiply",
          "expected_encoding": "48 F7 EB",
          "encoding_length": 3,
          "intel_reference": "REX.W + F7 /5 (IMUL r/m64)"
        },
        {
          "syntax": "imulq %rax, %rbx", 
          "description": "64-bit signed multiply with two operands",
          "expected_encoding": "48 0F AF D8",
          "encoding_length": 4,
          "intel_reference": "REX.W + 0F AF /r (IMUL r64, r/m64)"
        },
        {
          "syntax": "imulq $10, %rax, %rbx", 
          "description": "64-bit signed multiply with immediate",
          "expected_encoding": "48 6B D8 0A",
          "encoding_length": 4,
          "intel_reference": "REX.W + 6B /r ib (IMUL r64, r/m64, imm8)"
        }
      ]
    },
    {
      "mnemonic": "DIV",
      "description": "Unsigned divide",
      "operand_types": ["reg", "reg_mem"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "divq %rbx", 
          "description": "64-bit unsigned divide",
          "expected_encoding": "48 F7 F3",
          "encoding_length": 3,
          "intel_reference": "REX.W + F7 /6 (DIV r/m64)"
        },
        {
          "syntax": "divl %ebx", 
          "description": "32-bit unsigned divide",
          "expected_encoding": "F7 F3",
          "encoding_length": 2,
          "intel_reference": "F7 /6 (DIV r/m32)"
        }
      ]
    },
    {
      "mnemonic": "IDIV",
      "description": "Signed divide", 
      "operand_types": ["reg", "reg_mem"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "idivq %rbx", 
          "description": "64-bit signed divide",
          "expected_encoding": "48 F7 FB",
          "encoding_length": 3,
          "intel_reference": "REX.W + F7 /7 (IDIV r/m64)"
        },
        {
          "syntax": "idivl %ebx", 
          "description": "32-bit signed divide",
          "expected_encoding": "F7 FB",
          "encoding_length": 2,
          "intel_reference": "F7 /7 (IDIV r/m32)"
        }
      ]
    },
    {
      "mnemonic": "AND",
      "description": "Bitwise AND",
      "operand_types": ["reg", "reg_mem", "imm"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "andq %rax, %rbx", 
          "description": "64-bit bitwise AND",
          "expected_encoding": "48 21 C3",
          "encoding_length": 3,
          "intel_reference": "REX.W + 21 /r (AND r/m64, r64)"
        },
        {
          "syntax": "andq $0xFF, %rax", 
          "description": "AND with immediate",
          "expected_encoding": "48 83 E0 FF",
          "encoding_length": 4,
          "intel_reference": "REX.W + 83 /4 ib (AND r/m64, imm8)"
        }
      ]
    },
    {
      "mnemonic": "OR",
      "description": "Bitwise OR",
      "operand_types": ["reg", "reg_mem", "imm"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "orq %rax, %rbx", 
          "description": "64-bit bitwise OR",
          "expected_encoding": "48 09 C3",
          "encoding_length": 3,
          "intel_reference": "REX.W + 09 /r (OR r/m64, r64)"
        },
        {
          "syntax": "orq $0xFF, %rax", 
          "description": "OR with immediate",
          "expected_encoding": "48 83 C8 FF",
          "encoding_length": 4,
          "intel_reference": "REX.W + 83 /1 ib (OR r/m64, imm8)"
        }
      ]
    },
    {
      "mnemonic": "XOR",
      "description": "Bitwise XOR",
      "operand_types": ["reg", "reg_mem", "imm"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "xorq %rax, %rbx", 
          "description": "64-bit bitwise XOR",
          "expected_encoding": "48 31 C3",
          "encoding_length": 3,
          "intel_reference": "REX.W + 31 /r (XOR r/m64, r64)"
        },
        {
          "syntax": "xorq %rax, %rax", 
          "description": "Register zeroing idiom",
          "expected_encoding": "48 31 C0",
          "encoding_length": 3,
          "intel_reference": "REX.W + 31 /r (XOR r/m64, r64)"
        }
      ]
    },
    {
      "mnemonic": "NOT",
      "description": "Bitwise NOT",
      "operand_types": ["reg", "reg_mem"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "notq %rax", 
          "description": "64-bit bitwise NOT",
          "expected_encoding": "48 F7 D0",
          "encoding_length": 3,
          "intel_reference": "REX.W + F7 /2 (NOT r/m64)"
        }
      ]
    },
    {
      "mnemonic": "SHL",
      "description": "Shift left",
      "operand_types": ["reg", "reg_mem"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "shlq $1, %rax", 
          "description": "Shift left by 1",
          "expected_encoding": "48 D1 E0",
          "encoding_length": 3,
          "intel_reference": "REX.W + D1 /4 (SHL r/m64, 1)"
        },
        {
          "syntax": "shlq %cl, %rax", 
          "description": "Shift left by CL register",
          "expected_encoding": "48 D3 E0",
          "encoding_length": 3,
          "intel_reference": "REX.W + D3 /4 (SHL r/m64, CL)"
        }
      ]
    },
    {
      "mnemonic": "SHR",
      "description": "Shift right (logical)",
      "operand_types": ["reg", "reg_mem"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "shrq $1, %rax", 
          "description": "Shift right by 1",
          "expected_encoding": "48 D1 E8",
          "encoding_length": 3,
          "intel_reference": "REX.W + D1 /5 (SHR r/m64, 1)"
        },
        {
          "syntax": "shrq %cl, %rax", 
          "description": "Shift right by CL register",
          "expected_encoding": "48 D3 E8",
          "encoding_length": 3,
          "intel_reference": "REX.W + D3 /5 (SHR r/m64, CL)"
        }
      ]
    },
    {
      "mnemonic": "SAR",
      "description": "Shift right (arithmetic)",
      "operand_types": ["reg", "reg_mem"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "sarq $1, %rax", 
          "description": "Arithmetic shift right by 1",
          "expected_encoding": "48 D1 F8",
          "encoding_length": 3,
          "intel_reference": "REX.W + D1 /7 (SAR r/m64, 1)"
        },
        {
          "syntax": "sarq %cl, %rax", 
          "description": "Arithmetic shift right by CL",
          "expected_encoding": "48 D3 F8",
          "encoding_length": 3,
          "intel_reference": "REX.W + D3 /7 (SAR r/m64, CL)"
        }
      ]
    },
    {
      "mnemonic": "CMP",
      "description": "Compare operands",
      "operand_types": ["reg", "reg_mem", "imm"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "cmpq %rax, %rbx", 
          "description": "Compare 64-bit registers",
          "expected_encoding": "48 39 C3",
          "encoding_length": 3,
          "intel_reference": "REX.W + 39 /r (CMP r/m64, r64)"
        },
        {
          "syntax": "cmpq $0, %rax", 
          "description": "Compare with immediate",
          "expected_encoding": "48 83 F8 00",
          "encoding_length": 4,
          "intel_reference": "REX.W + 83 /7 ib (CMP r/m64, imm8)"
        }
      ]
    },
    {
      "mnemonic": "TEST",
      "description": "Test operands (bitwise AND without storing result)",
      "operand_types": ["reg", "reg_mem", "imm"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "testq %rax, %rax", 
          "description": "Test register against itself",
          "expected_encoding": "48 85 C0",
          "encoding_length": 3,
          "intel_reference": "REX.W + 85 /r (TEST r/m64, r64)"
        },
        {
          "syntax": "testq $0xFF, %rax", 
          "description": "Test with immediate mask",
          "expected_encoding": "48 F7 C0 FF 00 00 00",
          "encoding_length": 7,
          "intel_reference": "REX.W + F7 /0 id (TEST r/m64, imm32)"
        }
      ]
    }
  ]
}
