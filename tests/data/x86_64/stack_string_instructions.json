{
  "instruction_set": "x86_64_stack_string",
  "description": "Stack operations and string instructions",
  "reference": "Intel SDM Volume 2A",
  "instructions": [
    {
      "mnemonic": "PUSH",
      "description": "Push Word, Doubleword or Quadword Onto the Stack",
      "operand_types": ["reg", "mem", "imm"],
      "sizes": ["16", "32", "64"],
      "test_cases": [
        {
          "syntax": "pushq %rax", 
          "description": "Push 64-bit register",
          "expected_encoding": "50",
          "encoding_length": 1,
          "intel_reference": "50+rd (PUSH r64)",
          "note": "Single-byte opcode 50 + register encoding"
        },
        {
          "syntax": "pushl %eax", 
          "description": "Push 32-bit register",
          "expected_encoding": "50",
          "encoding_length": 1,
          "intel_reference": "50+rd (PUSH r32)",
          "note": "Single-byte opcode, defaults to 64-bit operand size in 64-bit mode"
        },
        {
          "syntax": "pushw %ax", 
          "description": "Push 16-bit register",
          "expected_encoding": "66 50",
          "encoding_length": 2,
          "intel_reference": "66 50+rw (PUSH r16)",
          "note": "Operand-size prefix 66 + single-byte opcode"
        },
        {
          "syntax": "pushq (%rax)", 
          "description": "Push memory operand",
          "expected_encoding": "FF 30",
          "encoding_length": 2,
          "intel_reference": "FF /6 (PUSH r/m64)",
          "note": "FF /6 + ModR/M=30 (mod=00 reg=110 r/m=000)"
        },
        {
          "syntax": "pushq $0x1234", 
          "description": "Push immediate value",
          "expected_encoding": "68 34 12 00 00",
          "encoding_length": 5,
          "intel_reference": "68 id (PUSH imm32)",
          "note": "68 + 32-bit immediate, sign-extended to 64-bit"
        },
        {
          "syntax": "pushq %r8", 
          "description": "Push extended register",
          "expected_encoding": "41 50",
          "encoding_length": 2,
          "intel_reference": "REX.B + 50+rd (PUSH r64)",
          "note": "REX.B=1 (41) + opcode 50"
        },
        {
          "syntax": "pushq variable(%rip)", 
          "description": "Push RIP-relative memory",
          "expected_encoding": "FF 35 00 00 00 00",
          "encoding_length": 6,
          "intel_reference": "FF /6 (PUSH r/m64)",
          "note": "FF /6 + ModR/M=35 + 32-bit RIP-relative displacement"
        }
      ]
    },
    {
      "mnemonic": "POP",
      "description": "Pop a Value from the Stack",
      "operand_types": ["reg", "mem"],
      "sizes": ["16", "32", "64"],
      "test_cases": [
        {
          "syntax": "popq %rax", 
          "description": "Pop to 64-bit register",
          "expected_encoding": "58",
          "encoding_length": 1,
          "intel_reference": "58+rd (POP r64)",
          "note": "Single-byte opcode 58 + register encoding"
        },
        {
          "syntax": "popl %eax", 
          "description": "Pop to 32-bit register",
          "expected_encoding": "58",
          "encoding_length": 1,
          "intel_reference": "58+rd (POP r32)",
          "note": "Single-byte opcode, defaults to 64-bit operand size in 64-bit mode"
        },
        {
          "syntax": "popw %ax", 
          "description": "Pop to 16-bit register",
          "expected_encoding": "66 58",
          "encoding_length": 2,
          "intel_reference": "66 58+rw (POP r16)",
          "note": "Operand-size prefix 66 + single-byte opcode"
        },
        {
          "syntax": "popq (%rax)", 
          "description": "Pop to memory operand",
          "expected_encoding": "8F 00",
          "encoding_length": 2,
          "intel_reference": "8F /0 (POP r/m64)",
          "note": "8F /0 + ModR/M=00 (mod=00 reg=000 r/m=000)"
        },
        {
          "syntax": "popq %r15", 
          "description": "Pop to extended register",
          "expected_encoding": "41 5F",
          "encoding_length": 2,
          "intel_reference": "REX.B + 5F (POP r64)",
          "note": "REX.B=1 (41) + opcode 5F (58+7 for R15)"
        }
      ]
    },
    {
      "mnemonic": "PUSHF",
      "description": "Push EFLAGS Register onto the Stack",
      "operand_types": ["none"],
      "sizes": ["16", "32", "64"],
      "test_cases": [
        {
          "syntax": "pushfq", 
          "description": "Push 64-bit flags (RFLAGS)",
          "expected_encoding": "9C",
          "encoding_length": 1,
          "intel_reference": "9C (PUSHF)",
          "note": "Single-byte opcode, pushes 64-bit RFLAGS in 64-bit mode"
        },
        {
          "syntax": "pushfl", 
          "description": "Push 32-bit flags (EFLAGS)",
          "expected_encoding": "9C",
          "encoding_length": 1,
          "intel_reference": "9C (PUSHF)",
          "note": "Same opcode, but pushes 64-bit RFLAGS in 64-bit mode"
        },
        {
          "syntax": "pushfw", 
          "description": "Push 16-bit flags (FLAGS)",
          "expected_encoding": "66 9C",
          "encoding_length": 2,
          "intel_reference": "66 9C (PUSHF)",
          "note": "Operand-size prefix 66 + 9C for 16-bit flags"
        }
      ]
    },
    {
      "mnemonic": "POPF",
      "description": "Pop Stack into EFLAGS Register",
      "operand_types": ["none"],
      "sizes": ["16", "32", "64"],
      "test_cases": [
        {
          "syntax": "popfq", 
          "description": "Pop to 64-bit flags (RFLAGS)",
          "expected_encoding": "9D",
          "encoding_length": 1,
          "intel_reference": "9D (POPF)",
          "note": "Single-byte opcode, pops to 64-bit RFLAGS in 64-bit mode"
        },
        {
          "syntax": "popfl", 
          "description": "Pop to 32-bit flags (EFLAGS)",
          "expected_encoding": "9D",
          "encoding_length": 1,
          "intel_reference": "9D (POPF)",
          "note": "Same opcode, but pops to 64-bit RFLAGS in 64-bit mode"
        },
        {
          "syntax": "popfw", 
          "description": "Pop to 16-bit flags (FLAGS)",
          "expected_encoding": "66 9D",
          "encoding_length": 2,
          "intel_reference": "66 9D (POPF)",
          "note": "Operand-size prefix 66 + 9D for 16-bit flags"
        }
      ]
    },
    {
      "mnemonic": "ENTER",
      "description": "Make Stack Frame for Procedure Parameters",
      "operand_types": ["imm16", "imm8"],
      "sizes": ["none"],
      "test_cases": [
        {"syntax": "enter $16, $0", "description": "Simple stack frame"},
        {"syntax": "enter $32, $1", "description": "Stack frame with nesting level"}
      ]
    },
    {
      "mnemonic": "LEAVE",
      "description": "High Level Procedure Exit",
      "operand_types": ["none"],
      "sizes": ["none"],
      "test_cases": [
        {"syntax": "leave", "description": "Restore stack frame"}
      ]
    },
    {
      "mnemonic": "MOVS",
      "description": "Move Data from String to String",
      "operand_types": ["none"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {
          "syntax": "movsq", 
          "description": "Move quadword from [RSI] to [RDI]",
          "expected_encoding": "48 A5",
          "encoding_length": 2,
          "intel_reference": "REX.W + A5 (MOVS m64, m64)",
          "note": "REX.W + A5 for 64-bit string move"
        },
        {
          "syntax": "movsl", 
          "description": "Move doubleword from [RSI] to [RDI]",
          "expected_encoding": "A5",
          "encoding_length": 1,
          "intel_reference": "A5 (MOVS m32, m32)",
          "note": "Single-byte opcode for 32-bit string move"
        },
        {
          "syntax": "movsw", 
          "description": "Move word from [RSI] to [RDI]",
          "expected_encoding": "66 A5",
          "encoding_length": 2,
          "intel_reference": "66 A5 (MOVS m16, m16)",
          "note": "Operand-size prefix + A5 for 16-bit string move"
        },
        {
          "syntax": "movsb", 
          "description": "Move byte from [RSI] to [RDI]",
          "expected_encoding": "A4",
          "encoding_length": 1,
          "intel_reference": "A4 (MOVS m8, m8)",
          "note": "Single-byte opcode for 8-bit string move"
        }
      ]
    },
    {
      "mnemonic": "CMPS",
      "description": "Compare String Operands",
      "operand_types": ["none"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {"syntax": "cmpsq", "description": "Compare quadwords [RSI] and [RDI]"},
        {"syntax": "cmpsl", "description": "Compare doublewords [RSI] and [RDI]"},
        {"syntax": "cmpsw", "description": "Compare words [RSI] and [RDI]"},
        {"syntax": "cmpsb", "description": "Compare bytes [RSI] and [RDI]"}
      ]
    },
    {
      "mnemonic": "SCAS",
      "description": "Scan String",
      "operand_types": ["none"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {"syntax": "scasq", "description": "Scan quadword in [RDI] against RAX"},
        {"syntax": "scasl", "description": "Scan doubleword in [RDI] against EAX"},
        {"syntax": "scasw", "description": "Scan word in [RDI] against AX"},
        {"syntax": "scasb", "description": "Scan byte in [RDI] against AL"}
      ]
    },
    {
      "mnemonic": "LODS",
      "description": "Load String",
      "operand_types": ["none"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {"syntax": "lodsq", "description": "Load quadword from [RSI] to RAX"},
        {"syntax": "lodsl", "description": "Load doubleword from [RSI] to EAX"},
        {"syntax": "lodsw", "description": "Load word from [RSI] to AX"},
        {"syntax": "lodsb", "description": "Load byte from [RSI] to AL"}
      ]
    },
    {
      "mnemonic": "STOS",
      "description": "Store String",
      "operand_types": ["none"],
      "sizes": ["8", "16", "32", "64"],
      "test_cases": [
        {"syntax": "stosq", "description": "Store RAX to [RDI]"},
        {"syntax": "stosl", "description": "Store EAX to [RDI]"},
        {"syntax": "stosw", "description": "Store AX to [RDI]"},
        {"syntax": "stosb", "description": "Store AL to [RDI]"}
      ]
    },
    {
      "mnemonic": "REP",
      "description": "Repeat String Operation Prefix",
      "operand_types": ["prefix"],
      "sizes": ["none"],
      "test_cases": [
        {"syntax": "rep movsb", "description": "Repeat move string bytes"},
        {"syntax": "rep stosq", "description": "Repeat store string quadwords"}
      ]
    },
    {
      "mnemonic": "REPE",
      "description": "Repeat String Operation While Equal Prefix",
      "operand_types": ["prefix"],
      "sizes": ["none"],
      "test_cases": [
        {"syntax": "repe cmpsb", "description": "Repeat compare while equal"},
        {"syntax": "repe scasb", "description": "Repeat scan while equal"}
      ]
    },
    {
      "mnemonic": "REPNE",
      "description": "Repeat String Operation While Not Equal Prefix",
      "operand_types": ["prefix"],
      "sizes": ["none"],
      "test_cases": [
        {"syntax": "repne scasb", "description": "Repeat scan while not equal"},
        {"syntax": "repne cmpsb", "description": "Repeat compare while not equal"}
      ]
    },
    {
      "mnemonic": "LEA",
      "description": "Load Effective Address",
      "operand_types": ["mem", "reg"],
      "sizes": ["16", "32", "64"],
      "test_cases": [
        {"syntax": "leaq (%rax), %rbx", "description": "Load effective address"},
        {"syntax": "leaq 16(%rax), %rbx", "description": "LEA with displacement"},
        {"syntax": "leaq (%rax,%rbx,2), %rcx", "description": "LEA with SIB"},
        {"syntax": "leaq 8(%rax,%rbx,4), %rcx", "description": "LEA with SIB and displacement"},
        {"syntax": "leaq data(%rip), %rax", "description": "LEA with RIP-relative addressing"},
        {"syntax": "leal (%eax), %ebx", "description": "32-bit LEA"},
        {"syntax": "leaw (%ax), %bx", "description": "16-bit LEA"}
      ]
    },
    {
      "mnemonic": "NOP",
      "description": "No Operation",
      "operand_types": ["none"],
      "sizes": ["none"],
      "test_cases": [
        {"syntax": "nop", "description": "Single-byte NOP"},
        {"syntax": "nopw (%rax)", "description": "Multi-byte NOP"}
      ]
    }
  ]
}
